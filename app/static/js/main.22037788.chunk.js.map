{"version":3,"sources":["component/Video.js","component/Videos.js","App.js","component/VideosC.js","AppCom.js","AppC.js","serviceWorker.js","index.js"],"names":["Video","props","useState","video","setVideo","useEffect","console","log","videoStream","srcObject","style","frameStyle","videoStyle","ref","id","muted","autoPlay","Videos","rVideos","setRVideos","tempVideos","remoteStreams","forEach","index","push","makeVideoView","name","onClick","switchVideo","display","key","cursor","objectFit","borderRadius","width","float","padding","stream","from","zIndex","position","backgroundColor","maxHeight","top","right","left","bottom","overflowX","whiteSpace","App","VideosC","Component","state","nextProps","this","setState","AppC","getLocalStream","navigator","mediaDevices","getUserMedia","mediaConstraints","then","localStream","whoIsOnline","catch","error","socketEventHandler","socket","on","data","newStatus","peerCount","status","selectedVideo","newRemoteStreams","filter","socketId","length","pc","peerConnections","addIceCandidate","RTCIceCandidate","candidate","sdpConstraints","createPeerConnection","createOffer","sdp","setLocalDescription","sendToServer","local","remote","e","addStream","setRemoteDescription","RTCSessionDescription","createAnswer","callback","pcConfig","RTCPeerConnection","tempPcConnections","onicecandidate","oniceconnectionstatechange","ontrack","remoteVideo","streams","remoteStream","tempRemoteStreams","close","type","payload","emit","statusTextView","color","serverUrl","iceServers","urls","mandatory","offerToReceiveVideo","offerToReceiveAudio","audio","options","mirror","io","height","margin","background","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.22037788.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\n\nfunction Video(props) {\n  const [video, setVideo] = useState(null);\n  useEffect(() => {\n      console.log(\"Video Called \", props)\n    if (video && props.videoStream) video.srcObject = props.videoStream;\n  }, [props.videoStream]);\n\n  return (\n    <div style={{ ...props.frameStyle }}>\n      <video\n        style={{ ...props.videoStyle }}\n        ref={props.videoStream}\n        id={props.id}\n        muted={props.muted}\n        autoPlay\n        ref={(ref) => setVideo(ref)}\n      />\n    </div>\n  );\n}\n\nexport default Video;\n","import React, { useState, useEffect } from \"react\";\nimport Video from \"./Video\";\n\nfunction Videos(props) {\n  const [rVideos, setRVideos] = useState([]);\n  const [remoteStreams, setRemoteStreams] = useState([]);\n\n  useEffect(() => {\n    // const _rVideos = props.remoteStreams.map((rVideo, index) => {\n    //   let video = (\n    //     <Video\n    //       videoStyle={{\n    //         cursor: \"pointer\",\n    //         objectFit: \"cover\",\n    //         borderRadius: 3,\n    //         width: \"100%\",\n    //       }}\n    //       frameStyle={{\n    //         width: 120,\n    //         float: \"left\",\n    //         padding: \"0 3px\",\n    //       }}\n    //       videoStream={rVideo.stream}\n    //     />\n    //   );\n\n    //   return (\n    //     <div\n    //       id={rVideo.name}\n    //       onClick={() => {\n    //         props.switchVideo(rVideo);\n    //       }}\n    //       style={{ display: \"inline-block\" }}\n    //       key={index}\n    //     >\n    //       {video}\n    //     </div>\n    //   );\n    // });\n\n    // setRemoteStreams(props.remoteStreams);\n    // setRVideos(_rVideos);\n    console.log(\"Videos props \", props);\n    let tempVideos = [];\n    props.remoteStreams.forEach((video, index) => {\n        tempVideos.push(makeVideoView(video, index))\n    })\n    console.log(\"Called Videos \", tempVideos);\n    setRVideos(tempVideos);\n  }, [props.remoteStreams]);\n\n  const makeVideoView = (video, index) => {\n      console.log(\"Make Video View\",index, video)\n    return (<div\n      id={video.name}\n      onClick={() => {\n        props.switchVideo(video);\n      }}\n      style={{ display: \"inline-block\" }}\n      key={index}\n    >\n      <Video\n        videoStyle={{\n          cursor: \"pointer\",\n          objectFit: \"cover\",\n          borderRadius: 3,\n          width: 120,\n        //   width: \"100%\",\n        }}\n        frameStyle={{\n        //   width: 120,\n          float: \"left\",\n          padding: \"0 3px\",\n        }}\n        videoStream={video.stream}\n        from = 'Videos'\n      />\n    </div>)\n  };\n\n  return (\n    <div\n      style={{\n        zIndex: 3,\n        position: \"fixed\",\n        padding: \"6px 3px\",\n        backgroundColor: \"rgb(0,0,0,0.3)\",\n        maxHeight: 120,\n        top: \"auto\",\n        right: 10,\n        left: 10,\n        bottom: 10,\n        overflowX: \"scroll\",\n        whiteSpace: \"nowrap\",\n      }}\n    >\n      {rVideos}\n    </div>\n  );\n}\n\nexport default Videos;\n","import React, { createRef, useEffect, useState } from \"react\";\nimport io from \"socket.io-client\";\nimport Video from \"./component/Video\";\nimport Videos from \"./component/Videos\";\n\nfunction App() {\n  const [localStream, setLocalStream] = useState(null);\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [remoteStreams, setRemoteStreams] = useState([]);\n  // const [peerConn, setPeerConn] = useState(null);\n  const [peerConnections, setPeerConnections] = useState({});\n  const [selectedVideo, setSelectedVideo] = useState(null);\n  const [status, setStatus] = useState(\"Please wait...\");\n  const [socket, setSocket] = useState(null);\n  const [serverUrl] = useState(\"https://947f3a2a.ngrok.io/\");\n  const [pcConfig] = useState({\n    iceServers: [\n      // {\n      //   urls: \"stun:numb.viagenie.ca\",\n      // },\n      // {\n      //   urls: \"turn:numb.viagenie.ca\",\n      //   credential: \"numb-@@95\",\n      //   username: \"yuba.oli@amniltech.com\",\n      // },\n      {\n        urls: \"stun:stun.l.google.com:19302\",\n      },\n    ],\n  });\n\n  const [sdpConstraints] = useState({\n    mandatory: {\n      offerToReceiveVideo: true,\n      offerToReceiveAudio: true,\n    },\n  });\n\n  const [mediaConstraints] = useState({\n    audio: true,\n    video: true,\n    // video:{\n    //   width: 1280,\n    //   height: 720\n    // },\n    // video: {\n    //   width:{min: 1280}\n    // },\n    options: {\n      mirror: true,\n    },\n  });\n\n  useEffect(() => {\n    setSocket(io(`${serverUrl}webrtcPeer`));\n    // setPeerConn(new RTCPeerConnection(pcConfig));\n  }, []);\n\n  useEffect(() => {\n    // if (peerConn) {\n    //   initPeerConnectionCallbacks();\n    // }\n    console.log(\"USE EFT \", localStream)\n    if(localStream){\n      socketEventHandler();\n      whoIsOnline();\n    }\n  }, [localStream]);\n\n  useEffect(() => {\n    if (socket) {\n      socketEventHandler();\n    }\n\n    return () => {\n      if (socket) socket.close();\n    };\n  }, [socket]);\n\n  useEffect(() => {\n    if(localStream){\n      socketEventHandler();\n      console.log(\"Selected Video Changed \", selectedVideo)\n    }\n  }, [selectedVideo])\n\n  // const initPeerConnectionCallbacks = () => {\n  //   peerConn.onicecandidate = (e) => {\n  //     if (e.candidate) {\n  //       console.log(\"onicecandidate Candidate \", e.candidate);\n  //       sendToServer(\"candidate\", e.candidate, socket.id);\n  //     }\n  //   };\n\n  //   peerConn.oniceconnectionstatechange = (e) => {\n  //     console.log(\"Ice connection changed\", e);\n  //   };\n\n  //   peerConn.ontrack = (e) => {\n  //     setRemoteStream(e.streams[0]);\n  //   };\n  // };\n\n  const getLocalStream = () => {\n    navigator.mediaDevices\n      .getUserMedia(mediaConstraints)\n      .then((stream) => {\n        setLocalStream(stream);\n        console.log(\"GetLocalStream \", stream )\n        // whoIsOnline();\n        // if (peerConn) peerConn.addStream(stream);\n      })\n      .catch((error) => {\n        console.log(\"Error while getting camera \", error);\n      });\n  };\n\n  const socketEventHandler = () => {\n    socket.on(\"connection-success\", (data) => {\n      getLocalStream();\n      console.log(\"New Peer Connected\", data);\n      setStatus(\n        data.peerCount > 1\n          ? `Total Connected Peers ${data.peerCount}`\n          : `Waiting for other peers to connect`\n      );\n    });\n\n    socket.on(\"peer-disconnected\", (data) => {\n      console.log(\"Disconnected peer\", data);\n      const newRemoteStreams = remoteStreams.filter(\n        (stream) => stream.id !== data.socketId\n      );\n      // check if disconnected peer is the selected video and if there still connected peers, then select the first\n      if (\n        selectedVideo &&\n        selectedVideo.id === data.socketId &&\n        remoteStreams.length\n      )\n        setSelectedVideo(remoteStreams[0]);\n\n      setRemoteStreams(newRemoteStreams);\n      setStatus(\n        data.peerCount > 1\n          ? `Total Connected Peers ${data.peerCount}`\n          : `Waiting for other peers to connect`\n      );\n    });\n\n    // socket.on(\"offerOrAnswer\", (sdp) => {\n    //   setTaValue(JSON.stringify(sdp));\n    //   peerConn.setRemoteDescription(new RTCSessionDescription(sdp));\n    // });\n\n    socket.on(\"candidate\", (data) => {\n      // get remote's peerConnection\n      console.log(\"on candidate \", data);\n      const pc = peerConnections[data.socketId];\n      if (pc) pc.addIceCandidate(new RTCIceCandidate(data.candidate));\n    });\n\n    socket.on(\"online-peer\", (socketId) => {\n      console.log(\"online-peer \", socketId);\n      console.log(\"online-peer\", \"Local Stream \", localStream)\n\n      //Create new peerConnection to the socketId client\n      createPeerConnection(socketId, (pc) => {\n        //Now create offer for the connected peer\n        if (pc) {\n          pc.createOffer(sdpConstraints).then(\n            (sdp) => {\n              pc.setLocalDescription(sdp);\n\n              sendToServer(\"offer\", sdp, {\n                local: socket.id,\n                remote: socketId,\n              });\n            },\n            (e) => {\n              console.log(\"Error create offer\", e);\n            }\n          );\n        }\n      });\n    });\n\n    socket.on(\"offer\", (data) => {\n      createPeerConnection(data.socketId, (pc) => {\n        if (pc) {\n          console.log(\"localStream\",localStream)\n          // pc.addStream(localStream);\n          pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).then(\n            () => {\n              //Create Answer\n              pc.createAnswer(sdpConstraints).then(\n                (sdp) => {\n                  pc.setLocalDescription(sdp);\n\n                  sendToServer(\"answer\", sdp, {\n                    local: socket.id,\n                    remote: data.socketId,\n                  });\n                },\n                (e) => {\n                  console.log(\"Error create answer\", e);\n                }\n              );\n            }\n          );\n        }\n      });\n    });\n\n    socket.on(\"answer\", (data) => {\n      // get remote's peerConnection\n      console.log(\"Answer Remote SDP \", data, peerConnections, remoteStreams);\n\n      const pc = peerConnections[data.socketId];\n      pc.setRemoteDescription(\n        new RTCSessionDescription(data.sdp)\n      ).then(() => {});\n    });\n  };\n\n  // const createOffer = () => {\n  //   peerConn.createOffer(sdpConstraints).then(\n  //     (sdp) => {\n  //       peerConn.setLocalDescription(sdp);\n  //       sendToServer(\"offerOrAnswer\", sdp, socket.id);\n  //     },\n  //     (e) => {\n  //       console.log(\"Error create offer\", e);\n  //     }\n  //   );\n  // };\n\n  // const createAnswer = () => {\n  //   peerConn.createAnswer(sdpConstraints).then(\n  //     (sdp) => {\n  //       peerConn.setLocalDescription(sdp);\n  //       sendToServer(\"offerOrAnswer\", sdp, socket.id);\n  //     },\n  //     (e) => {\n  //       console.log(\"Error create answer\", e);\n  //     }\n  //   );\n  // };\n\n  const createPeerConnection = (socketId, callback) => {\n    try {\n      let pc = new RTCPeerConnection(pcConfig);\n\n      //add pc to the collection of peerconnections i.e peerConnections\n      const tempPcConnections = peerConnections;\n      tempPcConnections[socketId] = pc;\n      setPeerConnections(tempPcConnections);\n\n      pc.onicecandidate = (e) => {\n        if (e.candidate) {\n          sendToServer(\"candidate\", e.candidate, {\n            local: socket.id,\n            remote: socketId,\n          });\n        }\n      };\n\n      pc.oniceconnectionstatechange = (e) => {\n        console.log(\"Ice connection changed\", e);\n        // if (pc.connectionState === \"disconnected\") {\n        //   const newRemoteStreams = remoteStreams.filter(\n        //     (stream) => stream.id !== socketId\n        //   );\n        //   setRemoteStream(\n        //     (newRemoteStreams.length > 0 && newRemoteStreams[0].stream) || null\n        //   );\n        // }\n      };\n\n      pc.ontrack = (e) => {\n        const remoteVideo = {\n          id: socketId,\n          name: socketId,\n          stream: e.streams[0],\n        };\n\n        // If there is already stream in display let it stay the same, otherwise use the latest stream\n        if (remoteStreams.length <= 0) setRemoteStream(e.streams[0]);\n\n        // get currently selected video\n        console.log(\"onTrack \", remoteStreams, selectedVideo)\n        let tempSelectedVdo = remoteStreams.filter(\n          (stream) => stream.id === selectedVideo.id\n        );\n        // if the video is still in the list, then do nothing, otherwise set to new video stream\n        if (!tempSelectedVdo.length) setSelectedVideo(remoteVideo);\n\n        const tempRemoteStreams = remoteStreams;\n        tempRemoteStreams.push(remoteVideo);\n        setRemoteStreams(tempRemoteStreams);\n      };\n\n      pc.close = () => {};\n\n      if (localStream) pc.addStream(localStream);\n\n      callback(pc);\n    } catch (error) {\n      console.log(\"Error while creating peer connections\", error);\n      callback(null);\n    }\n  };\n\n  const whoIsOnline = () => {\n    console.log(\"Who is Online \", \"Local Stream \", localStream)\n    sendToServer(\"onlinePeers\", null, { local: socket.id });\n  };\n\n  const sendToServer = (type, payload, socketId) => {\n    socket.emit(type, {\n      socketId,\n      payload,\n    });\n  };\n\n  const statusTextView = (\n    <div style={{ padding: 8, color: \"yellow\" }}>{status}</div>\n  );\n\n  return (\n    <div>\n      <Video\n        videoStyle={{\n          position: \"fixed\",\n          right: 0,\n          height: 300,\n          width: 300,\n          margin: 8,\n          zIndex: 2,\n          background: \"#0f0f0f\",\n        }}\n        videoStream={localStream}\n        autoPlay\n        muted\n      />\n\n      <Video\n        videoStyle={{\n          height: \"100%\",\n          width: \"100%\",\n          background: \"#0f0f0f\",\n          zIndex: 1,\n          position: \"fixed\",\n          bottom: 0,\n        }}\n        videoStream={selectedVideo && selectedVideo.stream}\n        autoPlay\n        muted\n      />\n      <br />\n      <div\n        style={{\n          zIndex: 3,\n          position: \"absolute\",\n          margin: 6,\n          padding: 6,\n          borderRadius: 6,\n          backgroundColor: \"#cdc4ff4f\",\n        }}\n      >\n        {statusTextView}\n      </div>\n      <div>\n        {console.log(\"Remote Streams \", remoteStreams)}\n        <Videos\n          switchVideo={(video) => setSelectedVideo(video)}\n          remoteStreams={remoteStreams}\n        />\n      </div>\n      {/* <div style={{ position: \"fixed\", zIndex: 1 }}>\n        <button onClick={() => createOffer()}>Create Offer</button>\n        <button onClick={() => createAnswer()}>Create Answer</button>\n        <br />\n        <textarea value={taValue} style={{ width: 450, height: 50 }} />\n      </div> */}\n    </div>\n  );\n}\n\nexport default App;\n","import React, { Component } from \"react\";\nimport Video from \"./Video\";\n\nclass VideosC extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      rVideos: [],\n      remoteStreams: [],\n    };\n  }\n\n  componentWillReceiveProps(nextProps) {\n    console.log(\"RemoteStreams Next props \", nextProps.remoteStreams);\n    console.log(\"RemoteStreams State \", this.state.remoteStreams);\n    if (this.state.remoteStreams !== nextProps.remoteStreams) {\n      console.log(\"Videos props \", this.props);\n      let tempVideos = [];\n      nextProps.remoteStreams.forEach((video, index) => {\n        tempVideos.push(this.makeVideoView(video, index));\n      });\n      console.log(\"Called Videos \", tempVideos);\n      this.setState({ rVideos: tempVideos });\n    }\n  }\n\n  makeVideoView = (video, index) => {\n    console.log(\"Make Video View\", index, video);\n    return (\n      <div\n        id={video.name}\n        onClick={() => {\n          this.props.switchVideo(video);\n        }}\n        style={{ display: \"inline-block\" }}\n        key={index}\n      >\n        <Video\n          videoStyle={{\n            cursor: \"pointer\",\n            objectFit: \"cover\",\n            borderRadius: 3,\n            width: 120,\n            //   width: \"100%\",\n          }}\n          frameStyle={{\n            //   width: 120,\n            float: \"left\",\n            padding: \"0 3px\",\n          }}\n          videoStream={video.stream}\n          from=\"Videos\"\n        />\n      </div>\n    );\n  };\n\n  render() {\n    return (\n      <div\n        style={{\n          zIndex: 3,\n          position: \"fixed\",\n          padding: \"6px 3px\",\n          backgroundColor: \"rgb(0,0,0,0.3)\",\n          maxHeight: 120,\n          top: \"auto\",\n          right: 10,\n          left: 10,\n          bottom: 10,\n          overflowX: \"scroll\",\n          whiteSpace: \"nowrap\",\n        }}\n      >\n        {this.state.rVideos}\n      </div>\n    );\n  }\n}\nexport default VideosC;\n","import React, { Component } from 'react';\n\nimport io from 'socket.io-client'\n\nimport Video from './component/Video'\nimport Videos from './component/Videos'\n\nclass AppCom extends Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      localStream: null,    // used to hold local stream object to avoid recreating the stream everytime a new offer comes\n      remoteStream: null,    // used to hold remote stream object that is displayed in the main screen\n\n      remoteStreams: [],    // holds all Video Streams (all remote streams)\n      peerConnections: {},  // holds all Peer Connections\n      selectedVideo: null,\n\n      status: 'Please wait...',\n\n      pc_config: {\n        \"iceServers\": [\n          {\n            urls: 'stun:stun.l.google.com:19302'\n          }\n        ]\n      },\n\n      sdpConstraints: {\n        'mandatory': {\n          'OfferToReceiveAudio': true,\n          'OfferToReceiveVideo': true\n        }\n      },\n    }\n\n    // DONT FORGET TO CHANGE TO YOUR URL\n    this.serviceIP = 'http://localhost:8080//webrtcPeer'\n\n    // https://reactjs.org/docs/refs-and-the-dom.html\n    // this.localVideoref = React.createRef()\n    // this.remoteVideoref = React.createRef()\n\n    this.socket = null\n    // this.candidates = []\n  }\n\n  getLocalStream = () => {\n    // called when getUserMedia() successfully returns - see below\n    // getUserMedia() returns a MediaStream object (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n    const success = (stream) => {\n      window.localStream = stream\n      // this.localVideoref.current.srcObject = stream\n      // this.pc.addStream(stream);\n      this.setState({\n        localStream: stream\n      })\n\n      this.whoisOnline()\n    }\n\n    // called when getUserMedia() fails - see below\n    const failure = (e) => {\n      console.log('getUserMedia Error: ', e)\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    // see the above link for more constraint options\n    const constraints = {\n      // audio: true,\n      video: true,\n      // video: {\n      //   width: 1280,\n      //   height: 720\n      // },\n      // video: {\n      //   width: { min: 1280 },\n      // }\n      options: {\n        mirror: true,\n      }\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.mediaDevices.getUserMedia(constraints)\n      .then(success)\n      .catch(failure)\n  }\n\n  whoisOnline = () => {\n    // let all peers know I am joining\n    this.sendToPeer('onlinePeers', null, { local: this.socket.id })\n  }\n\n  sendToPeer = (type, payload, socketId) => {\n    this.socket.emit(type, {\n      socketId,\n      payload\n    })\n  }\n\n  createPeerConnection = (socketId, callback) => {\n\n    try {\n      let pc = new RTCPeerConnection(this.state.pc_config)\n\n      // add pc to peerConnections object\n      const peerConnections = { ...this.state.peerConnections, [socketId]: pc }\n      this.setState({\n        peerConnections\n      })\n\n      pc.onicecandidate = (e) => {\n        if (e.candidate) {\n          this.sendToPeer('candidate', e.candidate, {\n            local: this.socket.id,\n            remote: socketId\n          })\n        }\n      }\n\n      pc.oniceconnectionstatechange = (e) => {\n        // if (pc.iceConnectionState === 'disconnected') {\n        //   const remoteStreams = this.state.remoteStreams.filter(stream => stream.id !== socketId)\n\n        //   this.setState({\n        //     remoteStream: remoteStreams.length > 0 && remoteStreams[0].stream || null,\n        //   })\n        // }\n\n      }\n\n      pc.ontrack = (e) => {\n        const remoteVideo = {\n          id: socketId,\n          name: socketId,\n          stream: e.streams[0]\n        }\n\n        this.setState(prevState => {\n\n          // If we already have a stream in display let it stay the same, otherwise use the latest stream\n          const remoteStream = prevState.remoteStreams.length > 0 ? {} : { remoteStream: e.streams[0] }\n\n          // get currently selected video\n          let selectedVideo = prevState.remoteStreams.filter(stream => stream.id === prevState.selectedVideo.id)\n          // if the video is still in the list, then do nothing, otherwise set to new video stream\n          selectedVideo = selectedVideo.length ? {} : { selectedVideo: remoteVideo }\n\n          return {\n            // selectedVideo: remoteVideo,\n            ...selectedVideo,\n            // remoteStream: e.streams[0],\n            ...remoteStream,\n            remoteStreams: [...prevState.remoteStreams, remoteVideo]\n          }\n        })\n      }\n\n      pc.close = () => {\n        // alert('GONE')\n      }\n\n      if (this.state.localStream)\n        pc.addStream(this.state.localStream)\n\n      // return pc\n      callback(pc)\n\n    } catch (e) {\n      console.log('Something went wrong! pc not created!!', e)\n      // return;\n      callback(null)\n    }\n  }\n\n  componentDidMount = () => {\n    // setSocket(io(`${serverUrl}webrtcPeer`));\n\n    this.socket = io.connect(\n      this.serviceIP\n    )\n\n    this.socket.on('connection-success', data => {\n\n      this.getLocalStream()\n\n      console.log(data.success)\n      const status = data.peerCount > 1 ? `Total Connected Peers: ${data.peerCount}` : 'Waiting for other peers to connect'\n\n      this.setState({\n        status: status\n      })\n    })\n\n    this.socket.on('peer-disconnected', data => {\n      console.log('peer-disconnected', data)\n\n      const remoteStreams = this.state.remoteStreams.filter(stream => stream.id !== data.socketId)\n\n      this.setState(prevState => {\n        // check if disconnected peer is the selected video and if there still connected peers, then select the first\n        const selectedVideo = prevState.selectedVideo.id === data.socketId && remoteStreams.length ? { selectedVideo: remoteStreams[0] } : null\n\n        return {\n          // remoteStream: remoteStreams.length > 0 && remoteStreams[0].stream || null,\n          remoteStreams,\n          ...selectedVideo,\n        }\n      }\n      )\n    })\n\n    // this.socket.on('offerOrAnswer', (sdp) => {\n\n    //   this.textref.value = JSON.stringify(sdp)\n\n    //   // set sdp as remote description\n    //   this.pc.setRemoteDescription(new RTCSessionDescription(sdp))\n    // })\n\n    this.socket.on('online-peer', socketId => {\n      console.log('connected peers ...', socketId)\n\n      // create and send offer to the peer (data.socketId)\n      // 1. Create new pc\n      this.createPeerConnection(socketId, pc => {\n        // 2. Create Offer\n        if (pc)\n          pc.createOffer(this.state.sdpConstraints)\n            .then(sdp => {\n              pc.setLocalDescription(sdp)\n\n              this.sendToPeer('offer', sdp, {\n                local: this.socket.id,\n                remote: socketId\n              })\n            })\n      })\n    })\n\n    this.socket.on('offer', data => {\n      this.createPeerConnection(data.socketId, pc => {\n        pc.addStream(this.state.localStream)\n\n        pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).then(() => {\n          // 2. Create Answer\n          pc.createAnswer(this.state.sdpConstraints)\n            .then(sdp => {\n              pc.setLocalDescription(sdp)\n\n              this.sendToPeer('answer', sdp, {\n                local: this.socket.id,\n                remote: data.socketId\n              })\n            })\n        })\n      })\n    })\n\n    this.socket.on('answer', data => {\n      // get remote's peerConnection\n      const pc = this.state.peerConnections[data.socketId]\n      console.log(data.sdp)\n      pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).then(() => { })\n    })\n\n    this.socket.on('candidate', (data) => {\n      // get remote's peerConnection\n      const pc = this.state.peerConnections[data.socketId]\n\n      if (pc)\n        pc.addIceCandidate(new RTCIceCandidate(data.candidate))\n    })\n\n    // const pc_config = null\n\n    // const pc_config = {\n    //   \"iceServers\": [\n    //     // {\n    //     //   urls: 'stun:[STUN_IP]:[PORT]',\n    //     //   'credentials': '[YOR CREDENTIALS]',\n    //     //   'username': '[USERNAME]'\n    //     // },\n    //     {\n    //       urls : 'stun:stun.l.google.com:19302'\n    //     }\n    //   ]\n    // }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection\n    // create an instance of RTCPeerConnection\n    // this.pc = new RTCPeerConnection(this.state.pc_config)\n\n    // triggered when a new candidate is returned\n    // this.pc.onicecandidate = (e) => {\n    //   // send the candidates to the remote peer\n    //   // see addCandidate below to be triggered on the remote peer\n    //   if (e.candidate) {\n    //     // console.log(JSON.stringify(e.candidate))\n    //     this.sendToPeer('candidate', e.candidate)\n    //   }\n    // }\n\n    // triggered when there is a change in connection state\n    // this.pc.oniceconnectionstatechange = (e) => {\n    //   console.log(e)\n    // }\n\n    // triggered when a stream is added to pc, see below - this.pc.addStream(stream)\n    // this.pc.onaddstream = (e) => {\n    //   this.remoteVideoref.current.srcObject = e.stream\n    // }\n\n    // this.pc.ontrack = (e) => {\n    //   debugger\n    //   // this.remoteVideoref.current.srcObject = e.streams[0]\n\n    //   this.setState({\n    //     remoteStream: e.streams[0]\n    //   })\n    // }\n\n  }\n\n  switchVideo = (_video) => {\n    console.log(_video)\n    this.setState({\n      selectedVideo: _video\n    })\n  }\n\n  render() {\n\n    console.log(this.state.localStream)\n\n    const statusText = <div style={{ color: 'yellow', padding: 5 }}>{this.state.status}</div>\n\n    return (\n      <div>\n        <Video\n          videoStyles={{\n            zIndex: 2,\n            position: 'absolute',\n            right: 0,\n            width: 200,\n            height: 200,\n            margin: 5,\n            backgroundColor: 'black'\n          }}\n          // ref={this.localVideoref}\n          videoStream={this.state.localStream}\n          autoPlay muted>\n        </Video>\n        <Video\n          videoStyles={{\n            zIndex: 1,\n            position: 'fixed',\n            bottom: 0,\n            minWidth: '100%',\n            minHeight: '100%',\n            backgroundColor: 'black'\n          }}\n          // ref={ this.remoteVideoref }\n          videoStream={this.state.selectedVideo && this.state.selectedVideo.stream}\n          autoPlay>\n        </Video>\n        <br />\n        <div style={{\n          zIndex: 3,\n          position: 'absolute',\n          margin: 10,\n          backgroundColor: '#cdc4ff4f',\n          padding: 10,\n          borderRadius: 5,\n        }}>\n          {statusText}\n        </div>\n        <div>\n          <Videos\n            switchVideo={this.switchVideo}\n            remoteStreams={this.state.remoteStreams}\n          ></Videos>\n        </div>\n        <br />\n\n        {/* <div style={{zIndex: 1, position: 'fixed'}} >\n          <button onClick={this.createOffer}>Offer</button>\n          <button onClick={this.createAnswer}>Answer</button>\n\n          <br />\n          <textarea style={{ width: 450, height:40 }} ref={ref => { this.textref = ref }} />\n        </div> */}\n        {/* <br />\n        <button onClick={this.setRemoteDescription}>Set Remote Desc</button>\n        <button onClick={this.addCandidate}>Add Candidate</button> */}\n      </div>\n    )\n  }\n}\n\nexport default AppCom;","import React, { Component } from \"react\";\nimport io from \"socket.io-client\";\nimport Video from \"./component/Video\";\nimport Videos from \"./component/VideosC\";\n\nclass AppC extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      localStream: null,\n      remoteStream: null,\n      remoteStreams: [],\n      peerConnections: {},\n      selectedVideo: null,\n      status: \"Please wait...\",\n      serverUrl: \"http://localhost:8080/\",\n      //   serverUrl: \"/\",\n      pcConfig: {\n        iceServers: [\n          // {\n          //   urls: \"stun:numb.viagenie.ca\",\n          // },\n          // {\n          //   urls: \"turn:numb.viagenie.ca\",\n          //   credential: \"numb-@@95\",\n          //   username: \"yuba.oli@amniltech.com\",\n          // },\n          {\n            urls: \"stun:stun.l.google.com:19302\",\n          },\n        ],\n      },\n      sdpConstraints: {\n        mandatory: {\n          offerToReceiveVideo: true,\n          offerToReceiveAudio: true,\n        },\n      },\n      mediaConstraints: {\n        audio: true,\n        video: true,\n        // video:{\n        //   width: 1280,\n        //   height: 720\n        // },\n        // video: {\n        //   width:{min: 1280}\n        // },\n        options: {\n          mirror: true,\n        },\n      },\n    };\n\n    this.socket = null;\n  }\n\n  componentDidMount() {\n    this.socket = io(`${this.state.serverUrl}webrtcPeer`);\n    this.socketEventHandler();\n  }\n\n  getLocalStream = () => {\n    navigator.mediaDevices\n      .getUserMedia(this.state.mediaConstraints)\n      .then((stream) => {\n        this.setState(\n          {\n            localStream: stream,\n          },\n          () => this.whoIsOnline()\n        );\n\n      })\n      .catch((error) => {\n        console.log(\"Error while getting camera \", error);\n      });\n  };\n\n  socketEventHandler = () => {\n    this.socket.on(\"connection-success\", (data) => {\n      this.getLocalStream();\n\n      const newStatus =\n        data.peerCount > 1\n          ? `Total Connected Peers ${data.peerCount}`\n          : `Waiting for other peers to connect`;\n\n      this.setState({\n        status: newStatus,\n      });\n    });\n\n    this.socket.on(\"joined-peers\", (data) => {\n\n      const newStatus =\n        data.peerCount > 1\n          ? `Total Connected Peers ${data.peerCount}`\n          : `Waiting for other peers to connect`;\n\n      this.setState({\n        status: newStatus,\n      });\n    });\n\n    this.socket.on(\"peer-disconnected\", (data) => {\n      const { selectedVideo, remoteStreams } = this.state;\n      const newRemoteStreams = [...remoteStreams].filter(\n        (stream) => stream.id !== data.socketId\n      );\n      const newStatus =\n        data.peerCount > 1\n          ? `Total Connected Peers ${data.peerCount}`\n          : `Waiting for other peers to connect`;\n      // check if disconnected peer is the selected video and if there still connected peers, then select the first\n      if (\n        selectedVideo &&\n        selectedVideo.id === data.socketId &&\n        remoteStreams.length\n      )\n        this.setState({\n          status: newStatus,\n          selectedVideo: remoteStreams[0],\n          remoteStreams: newRemoteStreams,\n        });\n    });\n\n    this.socket.on(\"candidate\", (data) => {\n      // get remote's peerConnection\n      const pc = this.state.peerConnections[data.socketId];\n      if (pc) pc.addIceCandidate(new RTCIceCandidate(data.candidate));\n    });\n\n    this.socket.on(\"online-peer\", (socketId) => {\n\n      const { sdpConstraints } = this.state;\n\n      //Create new peerConnection to the socketId client\n      this.createPeerConnection(socketId, (pc) => {\n        //Now create offer for the connected peer\n        if (pc) {\n          pc.createOffer(sdpConstraints).then(\n            (sdp) => {\n              pc.setLocalDescription(sdp);\n\n              this.sendToServer(\"offer\", sdp, {\n                local: this.socket.id,\n                remote: socketId,\n              });\n            },\n            (e) => {\n              console.log(\"Error create offer\", e);\n            }\n          );\n        }\n      });\n    });\n\n    this.socket.on(\"offer\", (data) => {\n      const { sdpConstraints, localStream } = this.state;\n      this.createPeerConnection(data.socketId, (pc) => {\n        if (pc) {\n          pc.addStream(localStream);\n          pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).then(\n            () => {\n              //Create Answer\n              pc.createAnswer(sdpConstraints).then(\n                (sdp) => {\n                  pc.setLocalDescription(sdp);\n\n                  this.sendToServer(\"answer\", sdp, {\n                    local: this.socket.id,\n                    remote: data.socketId,\n                  });\n                },\n                (e) => {\n                  console.log(\"Error create answer\", e);\n                }\n              );\n            }\n          );\n        }\n      });\n    });\n\n    this.socket.on(\"answer\", (data) => {\n      // get remote's peerConnection\n      const { peerConnections, remoteStreams } = this.state;\n\n      const pc = peerConnections[data.socketId];\n      pc.setRemoteDescription(\n        new RTCSessionDescription(data.sdp)\n      ).then(() => { });\n    });\n  };\n\n  createPeerConnection = (socketId, callback) => {\n    const {\n      peerConnections,\n      pcConfig,\n      remoteStreams,\n      selectedVideo,\n      localStream\n    } = this.state;\n    try {\n      let pc = new RTCPeerConnection(pcConfig);\n\n      //add pc to the collection of peerconnections i.e peerConnections\n      const tempPcConnections = { ...peerConnections };\n      tempPcConnections[socketId] = pc;\n      this.setState({\n        peerConnections: tempPcConnections,\n      });\n\n      pc.onicecandidate = (e) => {\n        if (e.candidate) {\n          this.sendToServer(\"candidate\", e.candidate, {\n            local: this.socket.id,\n            remote: socketId,\n          });\n        }\n      };\n\n      pc.oniceconnectionstatechange = (e) => {\n        // console.log(\"Ice connection changed\", e);\n        // if (pc.connectionState === \"disconnected\") {\n        //   const newRemoteStreams = remoteStreams.filter(\n        //     (stream) => stream.id !== socketId\n        //   );\n        //   setRemoteStream(\n        //     (newRemoteStreams.length > 0 && newRemoteStreams[0].stream) || null\n        //   );\n        // }\n      };\n\n      pc.ontrack = (e) => {\n        const remoteVideo = {\n          id: socketId,\n          name: socketId,\n          stream: e.streams[0],\n        };\n\n        // If there is already stream in display let it stay the same, otherwise use the latest stream\n        if (remoteStreams.length <= 0)\n          this.setState({ remoteStream: e.streams[0] });\n\n        // get currently selected video\n        let tempSelectedVdo = [...remoteStreams].filter(\n          (stream) => selectedVideo && stream.id === selectedVideo.id\n        );\n        // if the video is still in the list, then do nothing, otherwise set to new video stream\n        if (!tempSelectedVdo.length)\n          this.setState({ selectedVideo: remoteVideo });\n\n        const tempRemoteStreams = [...remoteStreams];\n        tempRemoteStreams.push(remoteVideo);\n\n        this.setState({ remoteStreams: tempRemoteStreams });\n      };\n\n      pc.close = () => { };\n\n      if (localStream) pc.addStream(localStream);\n\n      callback(pc);\n    } catch (error) {\n      console.log(\"Error while creating peer connections\", error);\n      callback(null);\n    }\n  };\n\n  whoIsOnline = () => {\n    this.sendToServer(\"onlinePeers\", null, { local: this.socket.id });\n  };\n\n  sendToServer = (type, payload, socketId) => {\n    this.socket.emit(type, {\n      socketId,\n      payload,\n    });\n  };\n\n  statusTextView = () => {\n    const { status } = this.state;\n    return (\n      <div style={{ padding: 8, color: \"yellow\" }}>{status}</div>\n    )\n  };\n\n  render() {\n    const { selectedVideo, remoteStreams, localStream } = this.state;\n    return (\n      <div>\n        <Video\n          videoStyle={{\n            position: \"fixed\",\n            right: 0,\n            height: 300,\n            width: 300,\n            margin: 8,\n            zIndex: 2,\n            background: \"#0f0f0f\",\n          }}\n          videoStream={localStream}\n          autoPlay\n          muted\n          from='AppC local'\n        />\n\n        <Video\n          videoStyle={{\n            height: \"100%\",\n            width: \"100%\",\n            background: \"#0f0f0f\",\n            zIndex: 1,\n            position: \"fixed\",\n            bottom: 0,\n          }}\n          videoStream={selectedVideo && selectedVideo.stream}\n          autoPlay\n          muted\n          from='AppC remote'\n        />\n        <br />\n        <div\n          style={{\n            zIndex: 3,\n            position: \"absolute\",\n            margin: 6,\n            padding: 6,\n            borderRadius: 6,\n            backgroundColor: \"#cdc4ff4f\",\n          }}\n        >\n          {this.statusTextView()}\n        </div>\n        <div>\n          {console.log(\"AppC remoteStreams \", remoteStreams)}\n          <Videos\n            switchVideo={(video) => this.setState({ selectedVideo: video })}\n            remoteStreams={this.state.remoteStreams}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default AppC;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport AppCom from './AppCom';\nimport AppC from './AppC';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <AppC />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}